import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import { executeQueryProof, getZKKYCStatus, ProofPoints } from '../blockchain/tx';
import {
  loadRegistrationProofOutputs,
  getCurrentDateFromBlockchain,
} from '../crypto/query-circuit-input';
import { getProviderAndWallet } from '../blockchain/eth';

/**
 * Parameters for query proof execution
 */
export interface ExecuteQueryProofParams {
  // User parameters
  userAddress?: string; // If not provided, uses wallet address from env

  // Identity parameters
  identityCreationTimestamp?: number; // Optional: timestamp restriction (0 = no restriction)
  minExpirationDate?: number; // Optional: minimum passport expiration date (0 = no restriction)

  // Passport data (from registration)
  passportHash?: string; // If not provided, derives from registration proof

  // Query proof (from generate-query-proof)
  queryProofPath?: string; // Path to query proof JSON (default: data/query-proof/query_proof.json)
  queryPublicPath?: string; // Path to public signals (default: data/query-proof/query_public.json)

  // Date parameter
  currentDate?: bigint; // Current date in hex ASCII format converted to decimal (e.g., 0x323531303330 = 55204039897904), auto-calculated if not provided

  // Registration root (usually 0 for now)
  registrationRoot?: string;
}

/**
 * Convert snarkjs proof format to ProofPoints for Solidity
 */
function convertProofToProofPoints(proof: any): ProofPoints {
  return {
    a: [proof.pi_a[0], proof.pi_a[1]],
    b: [
      [proof.pi_b[0][1], proof.pi_b[0][0]], // Note: b is reversed
      [proof.pi_b[1][1], proof.pi_b[1][0]],
    ],
    c: [proof.pi_c[0], proof.pi_c[1]],
  };
}

/**
 * Extract nullifier from query proof public signals
 * The public signals structure depends on the selector used
 * For selector 0x1 (nullifier only), it's the first signal
 */
function extractNullifier(publicSignals: string[]): bigint {
  // The nullifier is the first public signal
  return BigInt(publicSignals[0]);
}

/**
 * Derive passport hash from registration proof outputs
 * Uses loadRegistrationProofOutputs and converts to hex format for contract calls
 */
function derivePassportHashFromRegistration(): string {
  const { passportKey } = loadRegistrationProofOutputs();
  return ethers.toBeHex(passportKey, 32);
}

/**
 * Execute query proof for KYC verification
 *
 * This workflow:
 * 1. Loads the query proof generated by generate-query-proof
 * 2. Extracts the nullifier from public signals
 * 3. Derives passport hash from registration proof (or uses provided one)
 * 4. Calls QueryProofExecutor.execute() with the proof
 * 5. Verifies the transaction and displays the result
 *
 * Prerequisites:
 * - Registration proof must be generated (register-passport)
 * - Query proof must be generated (generate-query-proof)
 * - QueryProofExecutor contract must be deployed and configured
 *
 * @param params - Execution parameters
 */
export async function executeQueryProofWorkflow(params: ExecuteQueryProofParams) {
  console.log('=== Query Proof Execution Workflow ===\n');

  // Step 1: Load query proof
  const queryProofPath =
    params.queryProofPath || path.join(process.cwd(), 'data', 'query-proof', 'query_proof.json');
  const queryPublicPath =
    params.queryPublicPath || path.join(process.cwd(), 'data', 'query-proof', 'query_public.json');

  if (!fs.existsSync(queryProofPath)) {
    throw new Error(
      `Query proof not found at ${queryProofPath}. Please run generate-query-proof first.`,
    );
  }

  if (!fs.existsSync(queryPublicPath)) {
    throw new Error(
      `Query public signals not found at ${queryPublicPath}. Please run generate-query-proof first.`,
    );
  }

  const proof = JSON.parse(fs.readFileSync(queryProofPath, 'utf-8'));
  const publicSignals = JSON.parse(fs.readFileSync(queryPublicPath, 'utf-8'));

  console.log('✓ Loaded query proof from:', queryProofPath);
  console.log('✓ Loaded public signals from:', queryPublicPath);

  // Step 2: Extract nullifier from public signals
  const nullifier = extractNullifier(publicSignals);
  console.log('✓ Extracted nullifier:', nullifier.toString());

  // Step 3: Derive or use provided passport hash
  const passportHash = params.passportHash || derivePassportHashFromRegistration();
  console.log('✓ Passport hash:', passportHash);

  // Step 4: Determine user address
  const { wallet, provider } = getProviderAndWallet();
  const userAddress = params.userAddress || wallet.address;
  console.log('✓ User address:', userAddress);

  // Step 5: Prepare parameters
  const registrationRoot = params.registrationRoot || ethers.ZeroHash; // Usually 0 for now
  const currentDate = params.currentDate || (await getCurrentDateFromBlockchain(provider));
  const identityCreationTimestamp = params.identityCreationTimestamp || 0;
  const minExpirationDate = params.minExpirationDate || 0;

  console.log('\n=== Execution Parameters ===');
  console.log('User Address:', userAddress);
  console.log('Nullifier:', nullifier.toString());
  console.log('Passport Hash:', passportHash);
  console.log('Registration Root:', registrationRoot);
  console.log('Current Date:', currentDate);
  console.log('Identity Creation Timestamp:', identityCreationTimestamp);
  console.log('Min Expiration Date:', minExpirationDate);

  // Step 6: Convert proof to Solidity format
  const zkPoints = convertProofToProofPoints(proof);

  // Step 7: Execute transaction
  console.log('\n=== Executing Query Proof ===');
  const tx = await executeQueryProof(
    currentDate,
    userAddress,
    nullifier,
    passportHash,
    identityCreationTimestamp,
    minExpirationDate,
    zkPoints,
  );

  console.log('\n✅ Query proof executed successfully!');
  console.log('Transaction hash:', tx.hash);

  // Step 8: Verify the result
  console.log('\n=== Checking KYC Status ===');
  await getZKKYCStatus(userAddress);

  // Close provider connection to allow process to exit
  provider.destroy();

  return {
    transactionHash: tx.hash,
    userAddress,
    nullifier: nullifier.toString(),
    passportHash,
  };
}

/**
 * Check KYC status for an address without submitting a proof
 *
 * @param address - Address to check (defaults to wallet address)
 */
export async function checkKYCStatus(address?: string) {
  const { wallet, provider } = getProviderAndWallet();
  const userAddress = address || wallet.address;

  console.log('=== Checking KYC Status ===\n');
  console.log('Address:', userAddress);

  const result = await getZKKYCStatus(userAddress);

  if (result.isVerified) {
    console.log('\n✅ Address is KYC verified');
  } else {
    console.log('\n❌ Address is not KYC verified');
  }

  // Close provider connection to allow process to exit
  provider.destroy();

  return result;
}
