import { generateQueryProof, verifyQueryProof } from './generate-query-proof';
import {
  loadPkPassportHash,
  loadPkIdentityHash,
  encodePassportDate,
  loadLatestPassportData,
  calculateMinExpirationDate,
  loadRegistrationProofOutputs,
} from '../crypto/query-circuit-input';
import { readSkIdentity } from '../utils/bjj-key';
import { getProviderAndWallet, getQueryProofExecutorContract } from '../blockchain/eth';
import { ethers } from 'ethers';

export interface GenerateQueryProofFromContractParams {
  userAddress: string;
  minExpirationDate?: number;
}

/**
 * Generate query proof using parameters from contract's getPublicSignals
 * This ensures the proof matches what the contract expects
 *
 * @param params - Parameters for proof generation
 * @returns Generated proof and public signals
 */
export async function generateQueryProofFromContract(params: GenerateQueryProofFromContractParams) {
  console.log('\n=== Generating Query Proof from Contract Parameters ===\n');

  // Load passport data using common utility
  const { dg1Array, filename } = loadLatestPassportData();
  console.log('Loaded passport:', filename);

  // Load sk_identity
  const skIdentity = readSkIdentity();

  // User parameters
  const { userAddress } = params;

  // Get blockchain state
  const { provider, wallet } = getProviderAndWallet();
  const contract = getQueryProofExecutorContract(wallet);
  const block = await provider.getBlock('latest');

  if (!block) {
    throw new Error('Failed to get latest block');
  }

  const blockDate = new Date(block.timestamp * 1000);
  const currentDateEncoded = encodePassportDate(blockDate);
  const currentDateDecimal = BigInt(currentDateEncoded);
  const minExpirationDate = calculateMinExpirationDate(blockDate, 6); // 6 months from current date

  console.log('Block timestamp:', block.timestamp);
  console.log('Block date:', blockDate.toISOString());
  console.log('Current Date (encoded):', currentDateEncoded);
  console.log('Current Date (decimal):', currentDateDecimal.toString());

  // Get passport hash and session key
  const pkPassportHash = loadPkPassportHash();
  const passportHash = ethers.toBeHex(pkPassportHash, 32);
  const { identityKey } = loadRegistrationProofOutputs();
  const sessionKey = ethers.toBeHex(identityKey, 32);

  console.log('\nPassport hash:', passportHash);
  console.log('Session key:', sessionKey);
  console.log('User address:', userAddress);
  console.log('Min Expiration Date:', minExpirationDate);


  const userPayload = ethers.AbiCoder.defaultAbiCoder().encode(
    ['address', 'bytes32', 'bytes32', 'uint256'],
    [
      userAddress,
      sessionKey,
      passportHash,
      minExpirationDate,
    ],
  );

  console.log('\n=== Calling contract.getPublicSignals ===');

  // Call getPublicSignals to get expected parameters
  const expectedSignals = await contract.getPublicSignals(currentDateDecimal, userPayload);

  console.log('\n=== Expected Public Signals from Contract ===');
  console.log('Total signals:', expectedSignals.length);

  // Extract key parameters from expected signals
  // Structure:
  // [0] nullifier (will be generated by circuit, ignore)
  // [9] eventID
  // [10] eventData
  // [11] pkIdentityHash
  // [12] selector
  // [13] currentDate
  // [14] timestampLowerbound
  // [15] timestampUpperbound
  // [16] identityCounterLowerbound
  // [17] identityCounterUpperbound
  // [18] birthDateLowerbound
  // [19] birthDateUpperbound
  // [20] expirationDateLowerbound
  // [21] expirationDateUpperbound
  // [22] citizenshipMask

  const eventID = expectedSignals[9].toString();
  const eventData = expectedSignals[10].toString();
  const selector = Number(expectedSignals[12]);
  const timestampLowerbound = expectedSignals[14].toString();
  const timestampUpperbound = expectedSignals[15].toString();
  const identityCounterLowerbound = expectedSignals[16].toString();
  const identityCounterUpperbound = expectedSignals[17].toString();

  // Convert date bounds back to hex format (passport date format)
  const toHex = (val: bigint) => {
    const hex = val.toString(16).padStart(12, '0');
    return hex.startsWith('0x') ? hex : '0x' + hex;
  };

  const birthDateLowerbound = toHex(expectedSignals[18]);
  const birthDateUpperbound = toHex(expectedSignals[19]);
  const expirationDateLowerbound = toHex(expectedSignals[20]);
  const expirationDateUpperbound = toHex(expectedSignals[21]);

  const citizenshipMask = expectedSignals[22].toString();

  console.log('\n=== Extracted Parameters ===');
  console.log('Event ID:', eventID);
  console.log('Event Data:', eventData);
  console.log('Selector:', selector);
  console.log('Current Date:', currentDateEncoded);
  console.log('Timestamp bounds:', timestampLowerbound, '-', timestampUpperbound);
  console.log(
    'Identity counter bounds:',
    identityCounterLowerbound,
    '-',
    identityCounterUpperbound,
  );
  console.log('Birth date bounds:', birthDateLowerbound, '-', birthDateUpperbound);
  console.log('Expiration date bounds:', expirationDateLowerbound, '-', expirationDateUpperbound);
  console.log('Citizenship mask:', citizenshipMask);

  // Circuit expects 93 bytes (744 bits) of DG1
  const dg1Bytes = dg1Array.slice(0, 93);

  console.log('\n=== Generating Proof with Contract Parameters ===');

  const result = await generateQueryProof({
    dg1Bytes: dg1Bytes,
    skIdentity: skIdentity,
    pkPassportHash: pkPassportHash,
    pkIdentityHash: loadPkIdentityHash(),

    // Event parameters (from contract)
    eventID: eventID,
    eventData: eventData,

    // Current state
    timestamp: block.timestamp.toString(),
    currentDate: currentDateEncoded,
    identityCounter: '1',

    // Selector (from contract)
    selector: selector,

    // Bounds (from contract)
    timestampLowerbound: timestampLowerbound,
    timestampUpperbound: timestampUpperbound,
    identityCounterLowerbound: identityCounterLowerbound,
    identityCounterUpperbound: identityCounterUpperbound,
    birthDateLowerbound: birthDateLowerbound,
    birthDateUpperbound: birthDateUpperbound,
    expirationDateLowerbound: expirationDateLowerbound,
    expirationDateUpperbound: expirationDateUpperbound,

    // Citizenship mask (from contract)
    citizenshipMask: citizenshipMask,
  });

  console.log('\n✅ Query proof generated successfully!');
  console.log('Public signals count:', result.publicSignals.length);
  console.log('Nullifier:', result.publicSignals[0]);

  // Verify all signals match (except nullifier at [0])
  console.log('\n=== Verification: Comparing Generated vs Expected ===');
  let allMatch = true;
  for (let i = 1; i < result.publicSignals.length; i++) {
    // Convert both to BigInt for proper comparison
    const generated = BigInt(result.publicSignals[i]);
    const expected = BigInt(expectedSignals[i]);
    const match = generated === expected;
    if (!match) {
      console.log(`[${i}]: ✗ Generated: ${generated.toString()}, Expected: ${expected.toString()}`);
      allMatch = false;
    } else {
      console.log(`[${i}]: ✓ Match`);
    }
  }

  if (allMatch) {
    console.log('\n✅ All public signals match (except nullifier)!');
  } else {
    console.log('\n❌ Some public signals do not match!');
    console.log('Check the differences above.');
    throw new Error('Public signals do not match contract expectations');
  }

  // Additional verification: verify proof is cryptographically valid
  console.log('\n=== Cryptographic Proof Verification ===');
  const isValidProof = await verifyQueryProof(result.proof, result.publicSignals);

  if (isValidProof) {
    console.log('✅ Proof is cryptographically valid!');
  } else {
    console.log('❌ Proof verification failed!');
    throw new Error('Proof verification failed');
  }

  console.log('\n✅ All verifications passed! The proof is ready to be submitted to the contract.');

  // Close provider connection to allow process to exit
  provider.destroy();

  return result;
}
