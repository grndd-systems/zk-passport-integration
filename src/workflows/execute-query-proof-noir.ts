import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import { executeQueryProofNoir, getZKKYCStatus } from '../blockchain/tx';
import {
  loadRegistrationProofOutputs,
  getCurrentDateFromBlockchain,
  calculateMinExpirationDate,
} from '../crypto/query-circuit-input';
import { getProviderAndWallet } from '../blockchain/eth';

/**
 * Parameters for Noir query proof execution
 */
export interface ExecuteNoirQueryProofParams {
  // User parameters
  userAddress?: string; // If not provided, uses wallet address from env

  // Identity parameters
  identityCreationTimestamp?: number; // Optional: timestamp restriction (0 = no restriction)
  minExpirationDate?: number; // Optional: minimum passport expiration date (0 = no restriction)

  // Passport data (from registration)
  passportHash?: string; // If not provided, derives from registration proof
  sessionKey?: string; // Session key (identityKey) - if not provided, derives from registration proof

  // Query proof (from generate-query-proof-noir)
  queryProofPath?: string; // Path to query proof binary (default: data/query-proof-noir/query_proof)
  queryPublicPath?: string; // Path to public signals (default: data/query-proof-noir/public-inputs)

  // Date parameter
  currentDate?: bigint; // Current date in hex ASCII format converted to decimal (e.g., 0x323531303330 = 55204039897904), auto-calculated if not provided
}

/**
 * Extract nullifier from query proof public signals
 * The public signals structure depends on the selector used
 * For selector 0x1 (nullifier only), it's the first signal
 */
function extractNullifier(publicSignals: string[]): bigint {
  // The nullifier is the first public signal
  return BigInt(publicSignals[0]);
}

/**
 * Derive passport hash from registration proof outputs
 * Uses loadRegistrationProofOutputs and converts to hex format for contract calls
 */
function derivePassportHashFromRegistration(): string {
  const { passportKey } = loadRegistrationProofOutputs();
  return ethers.toBeHex(passportKey, 32);
}

/**
 * Load public inputs from file (one value per line)
 */
function loadPublicInputs(filePath: string): string[] {
  const content = fs.readFileSync(filePath, 'utf-8');
  return content
    .trim()
    .split('\n')
    .map((line) => line.trim())
    .filter((line) => line.length > 0);
}

/**
 * Execute Noir query proof for KYC verification
 *
 * This workflow:
 * 1. Loads the Noir query proof generated by generate-query-proof-noir
 * 2. Extracts the nullifier from public signals
 * 3. Derives passport hash from registration proof (or uses provided one)
 * 4. Calls QueryProofExecutor.executeNoir() with the proof
 * 5. Verifies the transaction and displays the result
 *
 * Prerequisites:
 * - Registration proof must be generated (register-passport)
 * - Noir query proof must be generated (generate-query-proof-noir)
 * - QueryProofExecutor contract must be deployed and configured
 *
 * @param params - Execution parameters
 */
export async function executeNoirQueryProofWorkflow(params: ExecuteNoirQueryProofParams) {
  console.log('=== Noir Query Proof Execution Workflow ===\n');

  // Step 1: Load Noir query proof (binary)
  const queryProofPath =
    params.queryProofPath || path.join(process.cwd(), 'data', 'query-proof-noir', 'query_proof');
  const queryPublicPath =
    params.queryPublicPath || path.join(process.cwd(), 'data', 'query-proof-noir', 'public-inputs');

  if (!fs.existsSync(queryProofPath)) {
    throw new Error(
      `Noir query proof not found at ${queryProofPath}. Please run generate-query-proof-noir first.`,
    );
  }

  if (!fs.existsSync(queryPublicPath)) {
    throw new Error(
      `Query public signals not found at ${queryPublicPath}. Please run generate-query-proof-noir first.`,
    );
  }

  // Read proof as binary (like in register-passport.ts)
  const zkPoints = fs.readFileSync(queryProofPath);
  const publicSignals = loadPublicInputs(queryPublicPath);

  console.log('✓ Loaded Noir query proof from:', queryProofPath);
  console.log('✓ Loaded public signals from:', queryPublicPath);
  console.log('✓ Proof size:', zkPoints.length, 'bytes');
  console.log('✓ Public signals count:', publicSignals.length);

  // Step 2: Extract nullifier from public signals
  const nullifier = extractNullifier(publicSignals);
  console.log('✓ Extracted nullifier:', nullifier.toString());

  // Step 3: Derive or use provided session key
  const sessionKey =
    params.sessionKey ||
    (() => {
      const { identityKey } = loadRegistrationProofOutputs();
      return ethers.toBeHex(identityKey, 32);
    })();
  console.log('✓ Session key:', sessionKey);

  // Step 4: Derive or use provided passport hash
  const passportHash = params.passportHash || derivePassportHashFromRegistration();
  console.log('✓ Passport hash:', passportHash);

  // Step 5: Determine user address
  const { wallet, provider } = getProviderAndWallet();
  const userAddress = params.userAddress || wallet.address;
  console.log('✓ User address:', userAddress);

  const block = await provider.getBlock('latest');
  if (!block) {
    throw new Error('Failed to get latest block');
  }
  const blockDate = new Date(block.timestamp * 1000);

  // Step 6: Prepare parameters
  const currentDate = params.currentDate || (await getCurrentDateFromBlockchain(provider));
  const minExpirationDate = calculateMinExpirationDate(blockDate, 6); // 6 months from current date

  console.log('\n=== Execution Parameters ===');
  console.log('User Address:', userAddress);
  console.log('Session Key:', sessionKey);
  console.log('Passport Hash:', passportHash);
  console.log('Current Date:', currentDate);
  console.log('Min Expiration Date:', minExpirationDate);

  // Step 7: Prepare userPayload (ABI-encoded)
  // Format: (address user, bytes32 sessionKey, bytes32 passportHash, uint256 minExpirationDate)
  const userPayload = ethers.AbiCoder.defaultAbiCoder().encode(
    ['address',  'bytes32', 'bytes32', 'uint256'],
    [
      userAddress,
      sessionKey,
      passportHash,
      minExpirationDate,
    ],
  );

  console.log('\n=== Executing Noir Query Proof ===');
  const tx = await executeQueryProofNoir(currentDate, userPayload, zkPoints);

  console.log('\n✅ Noir query proof executed successfully!');
  console.log('Transaction hash:', tx.hash);

  // Step 8: Verify the result
  console.log('\n=== Checking KYC Status ===');
  await getZKKYCStatus(userAddress);

  // Close provider connection to allow process to exit
  provider.destroy();

  return {
    transactionHash: tx.hash,
    userAddress,
    nullifier: nullifier.toString(),
    passportHash,
  };
}
